# -*- coding: utf-8 -*- 
"""
PyFem - Finite element software.
Raul Durand & Dorival Pedroso
Copyright 2010-2013.
"""

import os,sys
from math import log

from pyfem.tools.matvec import *
from pyfem.tools.stream import *
from shape_functions    import *
from block import *

class BlockInset(Block):
    def __init__(self):
        """
        Block class to discretize crossing elements
        ===========================================

        This discretizes entities as reinforcements that cross the mesh.
        For example, a reinforcement entitie can be discretized into several
        bar elements according to the tresspased elements. In addition, joint
        elements are created to link the tresspased elements with the bar
        elements.

        STORED:
            quadratic: Flag used to obtain discretized bars with three nodes.
            punctual : Flag used to generate punctual joint elements instead
                       of continuous joint elements.

        """

        Block.__init__(self)
        self.quadratic = True # Quadratic truss elements are generated by default
        self.neighbors = []   # Neighbor cells list to speed up cell look up
        self.punctual  = False  # Flag to define embedded punctual method

    def set_quadratic(self, value=True):
        """
        Defines if resulting bars are quadratic
        =======================================
        """

        self.quadratic = value

    def set_coords(self, C):
        """
        Sets the block coordinates
        ==========================

        input:
            C:  A list of lists with start and end coordinates of
                a crossing entity. A numpy matrix is also allowed.
        """

        ncols = len(C[0])
        nrows = len(C)
        self.coords = zeros(nrows, 3)
        self.coords[:,:ncols] = array(C)[:,:ncols]

    def get_cell_coords(self, S):
        """
        Constructs a matrix with cell coordinates
        ==========================================

        INPUT:
            S:  Cell object
        RETURNS:
            C: A matrix with the coordinates of a cell object
        """

        ndim = 3;
        sh_type = S.shape_type
        #if sh_type==TRI3 or sh_type==TRI6 or sh_type==QUAD4 or sh_type==QUAD8:
        if sh_type in [TRI3, TRI6, QUAD4, QUAD8]:
            ndim = 2
        else:
            ndim = 3

        C = empty(len(S.points), ndim)
        for i, point in enumerate(S.points):
            C[i,0] = point.x
            C[i,1] = point.y
            if ndim==3:
                C[i,2] = point.z

        return C

    def inverse_map(self, S, X):
        """
        Determines natural coordinates of a point given in global coordinates
        =====================================================================

        INPUT:
            S: Cell object
            X: List of global coordinates of a point
        RETURNS:
            R: List of natural coordinates of the given point
        """

        TOL   = 1.0E-7
        MAXIT = 25
        R = zeros(3)

        C = self.get_cell_coords(S)
        for k in range(MAXIT):
            # calculate Jacobian
            D = deriv_func(S.shape_type, R)
            J = mul(D, C)

            # calculate trial of real coordinates
            N  = shape_func(S.shape_type, R)
            Xt = mul(N.T, C).T # interpolating

            # calculate the error
            deltaX = Xt - X;
            deltaR = mul(inv(J).T, deltaX)

            # updating local coords R
            R -= deltaR
            if norm(deltaX) < TOL: break

        return R

    def bdistance(self, S, R):
        """
        Determines an estimate of the distance of a point to the border of a cell
        ==========================================================================

        INPUT:
            S:     Cell object
            R:     A list containing natural coordinates of the point
                   where the cell functions are evaluated
        RETURNS:
            value: An estimate of the distance to the border.
                   Positive value means that the point is inside the cell.
                   Negative value means that the point is outside the cell.
        """

        r, s, t = R[0], R[1], R[2]

        sh_type = S.shape_type

        if sh_type==TRI3 or sh_type==TRI6:
            assert False

        if sh_type==QUAD4 or sh_type==QUAD8:
            return min(1.0 - abs(r), 1.0 - (s))

        if sh_type==HEX8 or sh_type==HEX20:
            return min(1.0 - abs(r), 1.0 - abs(s), 1.0 - abs(t))

        if sh_type==TET4 or sh_type==TET10:
            return min(r, s, t, 1.0-r-s-t)

        return -1.0
        #raise Exception("Block_inset::bdistance: Could not find cell type.")

    def is_inside(self, S, X):
        """
        Determines if a point is inside a cell
        =======================================

        INPUT:
            S:      Cell object
            X:     List of global coordinates of a point
        RETURNS:
            value: True if the point is inside the cell
        """

        if S.shape_type in [LIN2, LIN3, LINK1, LINK2, LINK3]: return False

        TOL = 1.0E-7
        R = self.inverse_map(S, X)
        if self.bdistance(S, R) > -TOL:
            return True;
        else:
            return False;

    def find_cell(self, X, cells, near_cells=None):
        """
        Finds the cell that contains a given point
        ===========================================

        INPUT:
            X:            List of global coordinates of a point
            cells:       A list of cells
            near_cells:  A list of cells that is know that are close to
                          the given point
        RETURNS:
            cell:        The cell that contains the given point.
                          In the case of the point is not contained by any cell
                          from the list 'cells' then an exception is fired
        """

        if near_cells is not None:
            for cell in near_cells:
                if self.is_inside(cell, X):
                    return cell

        for cell in cells:
            if self.is_inside(cell, X):
                return cell

        raise Exception("Block_inset::find_cell: Coordinates outside mesh.")

    def find_neighbors(self, cells, points):
        """
        Finds neighbors cells (not being used)
        =======================================
        """

        pts_lst = sorted(points, key=lambda n: n.id)
        shp_lst = sorted(cells, key=lambda s: s.id)

        pt_sh_lst = []
        for p in pts_lst:
            pt_sh_lst.append([])

        self.neighbors = []
        for s in shp_lst:
            self.neighbors.append(set())

        for s in shp_lst:
            for pt in s.points:
                pt_sh_lst[pt.id].append(s)

        for sh_set in pt_sh_lst:
            for sh1 in sh_set:
                for sh2 in sh_set:
                    if sh1 is sh2: continue
                    self.neighbors[sh1.id].add(sh2)

    def split(self, points, cells, faces):
        """
        Performs the discretization of a crossing entity
        ================================================

        This function modifies a mesh (given as sets of points and cells)
        in order to add new cells and points corresponding to the
        discretization of a crossing entity.

        INPUT:
            points: A set of points of an existing mesh
            cells: A set of cells of an existing mesh
            faces : A set of faces. Not being used in this function but
                    inlcluded to math the function definition as in the
                    base class.
        RETURNS:
            None
        """

        #self.find_neighbors(cells, points)

        # Constants
        TINY = 1.0E-4
        TOL  = 1.0E-7

        # Getting initial and final coordinates
        X0 = self.coords[0,:] # Coordinate of first point
        X1 = self.coords[1,:] # Coordinate of last  point

        # Initial conditions
        length  = norm(X1-X0)
        tinylen = TINY*length
        bdist = 0.0        # boundary function initial value
        step  = length     # initial step length

        # Defining required vectors
        Xp = X0.copy()       # cell begin coordinates (previous point)
        X  = Xp.copy()       # test point coordinates
        T  = (X1-X0)/length  # unitary vector for the inset

        # Find the initial and final element
        init_cell  = self.find_cell(X0 + tinylen*T, cells) # The first tresspased cell

        if init_cell==None:
            print "Block_inset.split: Inset limits outside the mesh."

        # Flag for the first segment
        first_segment = True

        # Initializing more variables
        curr_cell = init_cell

        # Splitting inset
        while True:
            step = 0.5*norm(X1-X)
            X += step*T
            n = int(log(step/TOL,2)) + 1
            step0 = 0.0
            for i in range(n):
                R     = self.inverse_map(curr_cell, X)
                bdist = self.bdistance(curr_cell, R)
                step *= 0.5+TOL

                # Bisection algorithm
                if bdist>=-TOL: # (-TOL) is needed to aproximate the 'intersection' outside the cell
                    X += step*T # forward
                else:
                    X -= step*T # backward

                dstep = abs(step - step0)
                step0 = step

            if abs(dstep)>TOL:
                print "Block_inset.split: Bisection did not converge with dstep=%23.15e"%(bdist)


            # Getting line points
            P0 = points.add_new(X0) if first_segment else P1
            P1 = points.add_new(X)
            P2 = points.add_new((Xp + X)/2.0) if self.quadratic else None

            # Points
            Ps = [P0, P1, P2] if self.quadratic else [P0, P1]

            # Saving segment and related nodal points
            shape_type = LIN3 if self.quadratic else LIN2
            S = cells.add_new(shape_type, Ps, self.tag)

            # Saving link cell
            if self.punctual:
                # Creates discrete joint elements
                for P in Ps:
                    conn = curr_cell.points + [P]
                    Sj   = cells.add_new(LINK1, conn, self.tag)
                    Sj.lnk_cells = [S, curr_cell]
            else:
                # Create a continuous joint element
                shape_type = LINK3 if self.quadratic else LINK2
                conn = curr_cell.points + S.points
                Sj   = cells.add_new(shape_type, conn, self.tag)
                Sj.lnk_cells = [S, curr_cell]

            curr_len = norm(X-X0)
            if abs(curr_len - length) < TOL or curr_len > length: # Final segment
                P1.set_coords(X1)
                return

            # Preparing for the next segment
            Xp = X.copy()
            first_segment = False
            next_cell = self.find_cell(X + tinylen*T, cells) # The first tresspased cell
            #TODO: check if next_cell == None
            curr_cell = next_cell

    def split_back(self, points, cells, faces):
        """
        Performs the discretization of a crossed entity
        ===============================================

        This function modifies a mesh (given as sets of points and cells)
        in order to add new cells and points corresponding to the
        discretization of a crossing entity.

        INPUT:
            points: A set of points of an existing mesh
            cells: A set of cells of an existing mesh
            faces : A set of faces. Not being used in this function but
                    included to math the function definition as in the
                    base class.
        RETURNS:
            None
        """

        #self.find_neighbors(cells, points)

        # Constants
        TINY = 1.0E-3
        TOL  = 1.0E-4

        # Getting initial and final coordinates
        X0 = self.coords[0,:] # Coordinate of first point
        X1 = self.coords[1,:] # Coordinate of last  point

        # Initial conditions
        length  = norm(X1-X0)
        tinylen = TINY*length
        bdist = 0.0        # boundary function initial value
        step  = length     # initial step length

        # Defining required vectors
        Xp = X0.copy()       # cell begin coordinates (previous point)
        X  = Xp.copy()       # test point coordinates
        T  = (X1-X0)/length  # unitary vector for the inset

        # Find the initial and final element
        init_cell  = self.find_cell(X0 + tinylen*T, cells) # The first tresspased cell
        final_sh = self.find_cell(X1 - tinylen*T, cells) # The last tresspased cell
        near_cells = set([init_cell, final_sh])

        # Flag used to determine if the current segment is the final segment
        final_segment = True if init_cell==final_sh else False

        # Flag for the first segment
        first_segment = True

        # Initializing more variables
        curr_cell = prev_sh = init_cell
        next_cell = final_sh

        # Last point of previous segment point coordinates
        P1_prev = None

        # Splitting inset
        while True:
            #print step, bdist, curr_cell.id, prev_sh.id
            curr_cell = None
            if final_segment:
                X = X1.copy()
                prev_sh = curr_cell = final_sh
            else:
                step *= 0.5+TOL
                X    += step*T

                if self.is_inside(prev_sh, X):
                    curr_cell = prev_sh
                else:
                    curr_cell = self.find_cell(X, cells, near_cells)
                    near_cells.append(curr_cell)

            if curr_cell == prev_sh:
                if final_segment:
                    bdist = 0.0
                else:
                    R = self.inverse_map(next_cell, X)
                    bdist = abs(self.bdistance(next_cell, R))

                if bdist <= TOL:  # intersection is reached!!
                    # Saving segment and related nodal points
                    S = Cell()
                    S.tag = self.tag

                    S.shape_type = LIN3 if self.quadratic else LIN2

                    # First point
                    if first_segment:
                        tmpP = Point(X0)
                        P0 = tmpP.get_match_from(points)
                        if not P0: P0 = tmpP
                        P0.id = len(points)
                        points.add(P0)
                        S.points.append(P0)
                    else:
                        assert P1_prev
                        S.points.append(P1_prev)

                    # Second point
                    if final_segment:
                        tmpP = Point(X)
                        P1 = tmpP.get_match_from(points)
                        if not P1: P1 = tmpP
                        P1.id = len(points)
                        points.add(P1)
                        S.points.append(P1)
                    else:
                        P1 = Point(X)
                        P1.id = len(points)
                        points.add(P1)
                        S.points.append(P1)
                        P1_prev = P1

                    # Middle point
                    if self.quadratic:
                        Xn = (Xp + X)/2.0
                        P2 = Point(Xn)
                        P2.id = len(points)
                        points.add(P2)
                        S.points.append(P2)

                    first_segment = False
                    S.id = len(cells)
                    cells.append(S)

                    # Saving link cell
                    if self.punctual:
                        # Creates punctual joint elements
                        #Ps = [P0, P1]
                        #if self.quadratic: Ps.append(P2)
                        Ps = [P0, P1, P2] if self.quadratic else [P0, P1]

                        for P in Ps:
                            Sj = Cell()
                            Sj.shape_type = LINK1
                            Sj.tag = self.tag
                            Sj.points.extend(curr_cell.points)
                            Sj.points.append(P)
                            Sj.lnk_cells = [S, curr_cell]
                            Sj.id = len(cells)
                            cells.append(Sj)
                    else:
                        # Create a continuous joint element
                        Sj = Cell()
                        if not self.quadratic:
                            Sj.shape_type = LINK2
                        else:
                            Sj.shape_type = LINK3

                        Sj.tag = self.tag
                        Sj.points.extend(curr_cell.points) # uses trespassed element points
                        Sj.points.extend(S.points)       # adds bar points
                        Sj.lnk_cells = [S, curr_cell]
                        Sj.id = len(cells)
                        cells.append(Sj)

                    if final_segment: return

                    # Preparing for the next segment
                    Xp = X.copy()
                    if next_cell == final_sh:
                        final_segment = True
                    else:
                        prev_sh = next_cell
                        step = norm(X-X1)

                else: #when intersection is forward
                    step = abs(step) #advance
            else: #when intersection is backward
                step = -abs(step) #retrocession
                next_cell = curr_cell



