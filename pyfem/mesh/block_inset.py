import os,sys
from math import log

from pyfem.tools.matvec import *
from pyfem.tools.stream import *
from shape_functions    import *
from block import *

class BlockInset(Block):
    def __init__(self):
        """
        Block class to discretize crossing elements
        ===========================================

        This discretizes entities as reinforcements that cross the mesh.
        For example, a reinforcement entitie can be discretized into several
        bar elements according to the tresspased elements. In addition, joint
        elements are created to link the tresspased elements with the bar
        elements.

        STORED:
            quadratic: Flag used to obtain discretized bars with three nodes.
            punctual : Flag used to generate punctual joint elements instead
                       of continuous joint elements.

        """

        Block.__init__(self)
        self.quadratic = True # Quadratic truss elements are generated by default
        self.neighbors = []   # Neighbor shapes list to speed up shape look up
        self.punctual  = False  # Flag to define embedded punctual method

    def set_quadratic(self, value=True):
        """
        Defines if resulting bars are quadratic
        =======================================
        """

        self.quadratic = value

    def set_coords(self, C):
        """
        Sets the block coordinates
        ==========================

        input:
            C:  A list of lists with start and end coordinates of
                a crossing entity. A numpy matrix is also allowed.
        """

        ncols = len(C[0])
        nrows = len(C)
        self.coords = zeros(nrows, 3)
        self.coords[:,:ncols] = array(C)[:,:ncols]

    def get_cell_coords(self, S):
        """
        Constructs a matrix with shape coordinates
        ==========================================

        INPUT:
            S:  Cell object
        RETURNS:
            C: A matrix with the coordinates of a shape object
        """

        ndim = 3;
        sh_type = S.shape_type
        #if sh_type==TRI3 or sh_type==TRI6 or sh_type==QUAD4 or sh_type==QUAD8:
        if sh_type in [TRI3, TRI6, QUAD4, QUAD8]:
            ndim = 2
        else:
            ndim = 3

        C = empty(len(S.points), ndim)
        for i, point in enumerate(S.points):
            C[i,0] = point.x
            C[i,1] = point.y
            if ndim==3:
                C[i,2] = point.z

        return C

    def inverse_map(self, S, X):
        """
        Determines natural coordinates of a point given in global coordinates
        =====================================================================

        INPUT:
            S: Cell object
            X: List of global coordinates of a point
        RETURNS:
            R: List of natural coordinates of the given point
        """

        TOL   = 1.0E-7
        MAXIT = 25
        R = zeros(3)

        C = self.get_cell_coords(S)
        for k in range(MAXIT):
            # calculate Jacobian
            D = deriv_func(S.shape_type, R)
            J = mul(D, C)

            # calculate trial of real coordinates
            N  = shape_func(S.shape_type, R)
            Xt = mul(N.T, C).T # interpolating

            # calculate the error
            deltaX = Xt - X;
            deltaR = mul(inv(J).T, deltaX)

            # updating local coords R
            R -= deltaR
            if norm(deltaX) < TOL: break

        return R

    def bdistance(self, S, R):
        """
        Determines an estimate of the distance of a point to the border of a shape
        ==========================================================================

        INPUT:
            S:     Cell object
            R:     A list containing natural coordinates of the point
                   where the shape functions are evaluated
        RETURNS:
            value: An estimate of the distance to the border.
                   Positive value means that the point is inside the shape.
                   Negative value means that the point is outside the shape.
        """

        r, s, t = R[0], R[1], R[2]

        sh_type = S.shape_type

        if sh_type==TRI3 or sh_type==TRI6:
            assert False

        if sh_type==QUAD4 or sh_type==QUAD8:
            return min(1.0 - abs(r), 1.0 - (s))

        if sh_type==HEX8 or sh_type==HEX20:
            return min(1.0 - abs(r), 1.0 - abs(s), 1.0 - abs(t))

        if sh_type==TET4 or sh_type==TET10:
            return min(r, s, t, 1.0-r-s-t)

        return -1.0
        #raise Exception("Block_inset::bdistance: Could not find shape type.")

    def is_inside(self, S, X):
        """
        Determines if a point is inside a shape
        =======================================

        INPUT:
            S:      Cell object
            X:     List of global coordinates of a point
        RETURNS:
            value: True if the point is inside the shape
        """

        if S.shape_type in [LIN2, LIN3, LINK1, LINK2, LINK3]: return False

        TOL = 1.0E-7
        R = self.inverse_map(S, X)
        if self.bdistance(S, R) > -TOL:
            return True;
        else:
            return False;

    def find_shape(self, X, shapes, near_shapes=None):
        """
        Finds the shape that contains a given point
        ===========================================

        INPUT:
            X:            List of global coordinates of a point
            shapes:       A list of shapes
            near_shapes:  A list of shapes that is know that are close to
                          the given point
        RETURNS:
            shape:        The shape that contains the given point.
                          In the case of the point is not contained by any shape
                          from the list 'shapes' then an exception is fired
        """

        if near_shapes is not None:
            for shape in near_shapes:
                if self.is_inside(shape, X):
                    return shape

        for shape in shapes:
            if self.is_inside(shape, X):
                return shape

        raise Exception("Block_inset::find_shape: Coordinates outside mesh.")

    def find_neighbors(self, shapes, points):
        """
        Finds neighbors shapes (not being used)
        =======================================
        """

        pts_lst = sorted(points, key=lambda n: n.id)
        shp_lst = sorted(shapes, key=lambda s: s.id)

        pt_sh_lst = []
        for p in pts_lst:
            pt_sh_lst.append([])

        self.neighbors = []
        for s in shp_lst:
            self.neighbors.append(set())

        for s in shp_lst:
            for pt in s.points:
                pt_sh_lst[pt.id].append(s)

        for sh_set in pt_sh_lst:
            for sh1 in sh_set:
                for sh2 in sh_set:
                    if sh1 is sh2: continue
                    self.neighbors[sh1.id].add(sh2)

    def split(self, points, shapes, faces):
        """
        Performs the discretization of a crossed entity
        ===============================================

        This function modifies a mesh (given as sets of points and shapes)
        in order to add new shapes and points corresponding to the
        discretization of a crossing entity.

        INPUT:
            points: A set of points of an existing mesh
            shapes: A set of shapes of an existing mesh
            faces : A set of faces. Not being used in this function but
                    inlcluded to math the function definition as in the
                    base class.
        RETURNS:
            None
        """

        #self.find_neighbors(shapes, points)

        # Constants
        TINY = 1.0E-4
        TOL  = 1.0E-7

        # Getting initial and final coordinates
        X0 = self.coords[0,:] # Coordinate of first point
        X1 = self.coords[1,:] # Coordinate of last  point

        # Initial conditions
        length  = norm(X1-X0)
        tinylen = TINY*length
        bdist = 0.0        # boundary function initial value
        step  = length     # initial step length

        # Defining required vectors
        Xp = X0.copy()       # shape begin coordinates (previous point)
        X  = Xp.copy()       # test point coordinates
        T  = (X1-X0)/length  # unitary vector for the inset

        # Find the initial and final element
        init_sh  = self.find_shape(X0 + tinylen*T, shapes) # The first tresspased shape

        if init_sh==None:
            print "Block_inset.split: Inset limits outside the mesh."

        # Flag for the first segment
        first_segment = True

        # Initializing more variables
        curr_sh = init_sh

        # Splitting inset
        while True:
            step = 0.5*norm(X1-X)
            X += step*T
            n = int(log(step/TOL,2)) + 1
            step0 = 0.0
            for i in range(n):
                R     = self.inverse_map(curr_sh, X)
                bdist = self.bdistance(curr_sh, R)
                step *= 0.5+TOL

                # Bisection algorithm
                if bdist>=-TOL: # (-TOL) is needed to aproximate the 'intersection' outside the cell
                    X += step*T # forward
                else:
                    X -= step*T # backward

                dstep = abs(step - step0)
                step0 = step

            if abs(dstep)>TOL:
                print "Block_inset.split: Bisection did not converge with dstep=%23.15e"%(bdist)


            # Getting line points
            # First point
            P0 = Point(X0) if first_segment else P1

            # Second point
            P1 = Point(X)

            # Middle point
            P2 = Point((Xp + X)/2.0) if self.quadratic else None

            # Points
            Ps = [P0, P1, P2] if self.quadratic else [P0, P1]

            # Creating new points
            for i, P in enumerate(Ps):
                if i>0 or first_segment:
                    P.id = len(points)
                    points.add(P) # Warning with points that match background mesh points

            # Saving segment and related nodal points
            S             = Cell()
            S.tag         = self.tag
            S.shape_type  = LIN3 if self.quadratic else LIN2
            S.id          = len(shapes)
            shapes.append(S)
            for P in Ps:
                S.points.append(P)

            # Saving link shape
            if self.punctual:
                # Creates discrete joint elements
                for P in Ps:
                    Sj = Cell()
                    Sj.shape_type = LINK1
                    Sj.tag = self.tag
                    Sj.points.extend(curr_sh.points)
                    Sj.points.append(P)
                    Sj.lnk_shapes = [S, curr_sh]
                    Sj.id = len(shapes3)
                    shapes.append(Sj)
                    #cells.add_cell(type,points, tag=tag)
                    #add_cell(cells, type,points, tag=tag)
            else:
                # Create a continuous joint element
                Sj = Cell()
                if not self.quadratic:
                    Sj.shape_type = LINK2
                else:
                    Sj.shape_type = LINK3

                Sj.tag = self.tag
                Sj.points.extend(curr_sh.points) # uses trespassed element points
                Sj.points.extend(S.points)       # adds bar points
                Sj.lnk_shapes = [S, curr_sh]
                Sj.id = len(shapes)
                shapes.append(Sj)

            curr_len = norm(X-X0)
            if abs(curr_len - length) < TOL or curr_len > length: # Final segment
                P1.set_coords(X1)
                return

            # Preparing for the next segment
            Xp = X.copy()
            first_segment = False
            next_sh = self.find_shape(X + tinylen*T, shapes) # The first tresspased shape
            #TODO: check if next_sh == None
            curr_sh = next_sh

    def split_back(self, points, shapes, faces):
        """
        Performs the discretization of a crossed entity
        ===============================================

        This function modifies a mesh (given as sets of points and shapes)
        in order to add new shapes and points corresponding to the
        discretization of a crossing entity.

        INPUT:
            points: A set of points of an existing mesh
            shapes: A set of shapes of an existing mesh
            faces : A set of faces. Not being used in this function but
                    included to math the function definition as in the
                    base class.
        RETURNS:
            None
        """

        #self.find_neighbors(shapes, points)

        # Constants
        TINY = 1.0E-3
        TOL  = 1.0E-4

        # Getting initial and final coordinates
        X0 = self.coords[0,:] # Coordinate of first point
        X1 = self.coords[1,:] # Coordinate of last  point

        # Initial conditions
        length  = norm(X1-X0)
        tinylen = TINY*length
        bdist = 0.0        # boundary function initial value
        step  = length     # initial step length

        # Defining required vectors
        Xp = X0.copy()       # shape begin coordinates (previous point)
        X  = Xp.copy()       # test point coordinates
        T  = (X1-X0)/length  # unitary vector for the inset

        # Find the initial and final element
        init_sh  = self.find_shape(X0 + tinylen*T, shapes) # The first tresspased shape
        final_sh = self.find_shape(X1 - tinylen*T, shapes) # The last tresspased shape
        near_shapes = set([init_sh, final_sh])

        # Flag used to determine if the current segment is the final segment
        final_segment = True if init_sh==final_sh else False

        # Flag for the first segment
        first_segment = True

        # Initializing more variables
        curr_sh = prev_sh = init_sh
        next_sh = final_sh

        # Last point of previous segment point coordinates
        P1_prev = None

        # Splitting inset
        while True:
            #print step, bdist, curr_sh.id, prev_sh.id
            curr_sh = None
            if final_segment:
                X = X1.copy()
                prev_sh = curr_sh = final_sh
            else:
                step *= 0.5+TOL
                X    += step*T

                if self.is_inside(prev_sh, X):
                    curr_sh = prev_sh
                else:
                    curr_sh = self.find_shape(X, shapes, near_shapes)
                    near_shapes.append(curr_sh)

            if curr_sh == prev_sh:
                if final_segment:
                    bdist = 0.0
                else:
                    R = self.inverse_map(next_sh, X)
                    bdist = abs(self.bdistance(next_sh, R))

                if bdist <= TOL:  # intersection is reached!!
                    # Saving segment and related nodal points
                    S = Cell()
                    S.tag = self.tag

                    S.shape_type = LIN3 if self.quadratic else LIN2

                    # First point
                    if first_segment:
                        tmpP = Point(X0)
                        P0 = tmpP.get_match_from(points)
                        if not P0: P0 = tmpP
                        P0.id = len(points)
                        points.add(P0)
                        S.points.append(P0)
                    else:
                        assert P1_prev
                        S.points.append(P1_prev)

                    # Second point
                    if final_segment:
                        tmpP = Point(X)
                        P1 = tmpP.get_match_from(points)
                        if not P1: P1 = tmpP
                        P1.id = len(points)
                        points.add(P1)
                        S.points.append(P1)
                    else:
                        P1 = Point(X)
                        P1.id = len(points)
                        points.add(P1)
                        S.points.append(P1)
                        P1_prev = P1

                    # Middle point
                    if self.quadratic:
                        Xn = (Xp + X)/2.0
                        P2 = Point(Xn)
                        P2.id = len(points)
                        points.add(P2)
                        S.points.append(P2)

                    first_segment = False
                    S.id = len(shapes)
                    shapes.append(S)

                    # Saving link shape
                    if self.punctual:
                        # Creates punctual joint elements
                        #Ps = [P0, P1]
                        #if self.quadratic: Ps.append(P2)
                        Ps = [P0, P1, P2] if self.quadratic else [P0, P1]

                        for P in Ps:
                            Sj = Cell()
                            Sj.shape_type = LINK1
                            Sj.tag = self.tag
                            Sj.points.extend(curr_sh.points)
                            Sj.points.append(P)
                            Sj.lnk_shapes = [S, curr_sh]
                            Sj.id = len(shapes)
                            shapes.append(Sj)
                    else:
                        # Create a continuous joint element
                        Sj = Cell()
                        if not self.quadratic:
                            Sj.shape_type = LINK2
                        else:
                            Sj.shape_type = LINK3

                        Sj.tag = self.tag
                        Sj.points.extend(curr_sh.points) # uses trespassed element points
                        Sj.points.extend(S.points)       # adds bar points
                        Sj.lnk_shapes = [S, curr_sh]
                        Sj.id = len(shapes)
                        shapes.append(Sj)

                    if final_segment: return

                    # Preparing for the next segment
                    Xp = X.copy()
                    if next_sh == final_sh:
                        final_segment = True
                    else:
                        prev_sh = next_sh
                        step = norm(X-X1)

                else: #when intersection is forward
                    step = abs(step) #advance
            else: #when intersection is backward
                step = -abs(step) #retrocession
                next_sh = curr_sh



